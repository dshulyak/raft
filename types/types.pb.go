// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types/types.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Entry_OpType int32

const (
	Entry_EMPTY Entry_OpType = 0
	Entry_NOOP  Entry_OpType = 1
	Entry_APP   Entry_OpType = 2
	Entry_CONF  Entry_OpType = 3
)

var Entry_OpType_name = map[int32]string{
	0: "EMPTY",
	1: "NOOP",
	2: "APP",
	3: "CONF",
}

var Entry_OpType_value = map[string]int32{
	"EMPTY": 0,
	"NOOP":  1,
	"APP":   2,
	"CONF":  3,
}

func (x Entry_OpType) String() string {
	return proto.EnumName(Entry_OpType_name, int32(x))
}

func (Entry_OpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{3, 0}
}

type LogHeader struct {
	Term  uint64 `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Index uint64 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *LogHeader) Reset()         { *m = LogHeader{} }
func (m *LogHeader) String() string { return proto.CompactTextString(m) }
func (*LogHeader) ProtoMessage()    {}
func (*LogHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0}
}
func (m *LogHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogHeader.Merge(m, src)
}
func (m *LogHeader) XXX_Size() int {
	return m.Size()
}
func (m *LogHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_LogHeader.DiscardUnknown(m)
}

var xxx_messageInfo_LogHeader proto.InternalMessageInfo

func (m *LogHeader) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *LogHeader) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

type RequestVote struct {
	Term      uint64    `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Candidate NodeID    `protobuf:"varint,2,opt,name=candidate,proto3,casttype=NodeID" json:"candidate,omitempty"`
	PreVote   bool      `protobuf:"varint,3,opt,name=preVote,proto3" json:"preVote,omitempty"`
	LastLog   LogHeader `protobuf:"bytes,4,opt,name=lastLog,proto3" json:"lastLog"`
}

func (m *RequestVote) Reset()         { *m = RequestVote{} }
func (m *RequestVote) String() string { return proto.CompactTextString(m) }
func (*RequestVote) ProtoMessage()    {}
func (*RequestVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{1}
}
func (m *RequestVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestVote.Merge(m, src)
}
func (m *RequestVote) XXX_Size() int {
	return m.Size()
}
func (m *RequestVote) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestVote.DiscardUnknown(m)
}

var xxx_messageInfo_RequestVote proto.InternalMessageInfo

func (m *RequestVote) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RequestVote) GetCandidate() NodeID {
	if m != nil {
		return m.Candidate
	}
	return 0
}

func (m *RequestVote) GetPreVote() bool {
	if m != nil {
		return m.PreVote
	}
	return false
}

func (m *RequestVote) GetLastLog() LogHeader {
	if m != nil {
		return m.LastLog
	}
	return LogHeader{}
}

type RequestVoteResponse struct {
	Term        uint64 `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Voter       NodeID `protobuf:"varint,2,opt,name=voter,proto3,casttype=NodeID" json:"voter,omitempty"`
	PreVote     bool   `protobuf:"varint,3,opt,name=preVote,proto3" json:"preVote,omitempty"`
	VoteGranted bool   `protobuf:"varint,4,opt,name=voteGranted,proto3" json:"voteGranted,omitempty"`
}

func (m *RequestVoteResponse) Reset()         { *m = RequestVoteResponse{} }
func (m *RequestVoteResponse) String() string { return proto.CompactTextString(m) }
func (*RequestVoteResponse) ProtoMessage()    {}
func (*RequestVoteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{2}
}
func (m *RequestVoteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestVoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestVoteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestVoteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestVoteResponse.Merge(m, src)
}
func (m *RequestVoteResponse) XXX_Size() int {
	return m.Size()
}
func (m *RequestVoteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestVoteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RequestVoteResponse proto.InternalMessageInfo

func (m *RequestVoteResponse) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RequestVoteResponse) GetVoter() NodeID {
	if m != nil {
		return m.Voter
	}
	return 0
}

func (m *RequestVoteResponse) GetPreVote() bool {
	if m != nil {
		return m.PreVote
	}
	return false
}

func (m *RequestVoteResponse) GetVoteGranted() bool {
	if m != nil {
		return m.VoteGranted
	}
	return false
}

type Entry struct {
	Term  uint64       `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Index uint64       `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Type  Entry_OpType `protobuf:"varint,3,opt,name=type,proto3,enum=types.Entry_OpType" json:"type,omitempty"`
	Op    []byte       `protobuf:"bytes,4,opt,name=op,proto3" json:"op,omitempty"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{3}
}
func (m *Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return m.Size()
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

func (m *Entry) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *Entry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Entry) GetType() Entry_OpType {
	if m != nil {
		return m.Type
	}
	return Entry_EMPTY
}

func (m *Entry) GetOp() []byte {
	if m != nil {
		return m.Op
	}
	return nil
}

type AppendEntries struct {
	Term      uint64    `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Leader    NodeID    `protobuf:"varint,2,opt,name=leader,proto3,casttype=NodeID" json:"leader,omitempty"`
	PrevLog   LogHeader `protobuf:"bytes,3,opt,name=prevLog,proto3" json:"prevLog"`
	Commited  uint64    `protobuf:"varint,4,opt,name=commited,proto3" json:"commited,omitempty"`
	ReadIndex uint64    `protobuf:"varint,5,opt,name=readIndex,proto3" json:"readIndex,omitempty"`
	Entries   []*Entry  `protobuf:"bytes,6,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (m *AppendEntries) Reset()         { *m = AppendEntries{} }
func (m *AppendEntries) String() string { return proto.CompactTextString(m) }
func (*AppendEntries) ProtoMessage()    {}
func (*AppendEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{4}
}
func (m *AppendEntries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendEntries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendEntries.Merge(m, src)
}
func (m *AppendEntries) XXX_Size() int {
	return m.Size()
}
func (m *AppendEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendEntries.DiscardUnknown(m)
}

var xxx_messageInfo_AppendEntries proto.InternalMessageInfo

func (m *AppendEntries) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *AppendEntries) GetLeader() NodeID {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *AppendEntries) GetPrevLog() LogHeader {
	if m != nil {
		return m.PrevLog
	}
	return LogHeader{}
}

func (m *AppendEntries) GetCommited() uint64 {
	if m != nil {
		return m.Commited
	}
	return 0
}

func (m *AppendEntries) GetReadIndex() uint64 {
	if m != nil {
		return m.ReadIndex
	}
	return 0
}

func (m *AppendEntries) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type AppendEntriesResponse struct {
	Term      uint64    `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Follower  NodeID    `protobuf:"varint,2,opt,name=follower,proto3,casttype=NodeID" json:"follower,omitempty"`
	Success   bool      `protobuf:"varint,3,opt,name=success,proto3" json:"success,omitempty"`
	LastLog   LogHeader `protobuf:"bytes,4,opt,name=lastLog,proto3" json:"lastLog"`
	ReadIndex uint64    `protobuf:"varint,5,opt,name=readIndex,proto3" json:"readIndex,omitempty"`
}

func (m *AppendEntriesResponse) Reset()         { *m = AppendEntriesResponse{} }
func (m *AppendEntriesResponse) String() string { return proto.CompactTextString(m) }
func (*AppendEntriesResponse) ProtoMessage()    {}
func (*AppendEntriesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{5}
}
func (m *AppendEntriesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendEntriesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendEntriesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendEntriesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendEntriesResponse.Merge(m, src)
}
func (m *AppendEntriesResponse) XXX_Size() int {
	return m.Size()
}
func (m *AppendEntriesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendEntriesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AppendEntriesResponse proto.InternalMessageInfo

func (m *AppendEntriesResponse) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *AppendEntriesResponse) GetFollower() NodeID {
	if m != nil {
		return m.Follower
	}
	return 0
}

func (m *AppendEntriesResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *AppendEntriesResponse) GetLastLog() LogHeader {
	if m != nil {
		return m.LastLog
	}
	return LogHeader{}
}

func (m *AppendEntriesResponse) GetReadIndex() uint64 {
	if m != nil {
		return m.ReadIndex
	}
	return 0
}

type Message struct {
	// Types that are valid to be assigned to Type:
	//	*Message_ReqVote
	//	*Message_ReqVoteResp
	//	*Message_Append
	//	*Message_AppendResp
	Type isMessage_Type `protobuf_oneof:"type"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{6}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

type isMessage_Type interface {
	isMessage_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Message_ReqVote struct {
	ReqVote *RequestVote `protobuf:"bytes,1,opt,name=reqVote,proto3,oneof" json:"reqVote,omitempty"`
}
type Message_ReqVoteResp struct {
	ReqVoteResp *RequestVoteResponse `protobuf:"bytes,2,opt,name=reqVoteResp,proto3,oneof" json:"reqVoteResp,omitempty"`
}
type Message_Append struct {
	Append *AppendEntries `protobuf:"bytes,3,opt,name=append,proto3,oneof" json:"append,omitempty"`
}
type Message_AppendResp struct {
	AppendResp *AppendEntriesResponse `protobuf:"bytes,4,opt,name=appendResp,proto3,oneof" json:"appendResp,omitempty"`
}

func (*Message_ReqVote) isMessage_Type()     {}
func (*Message_ReqVoteResp) isMessage_Type() {}
func (*Message_Append) isMessage_Type()      {}
func (*Message_AppendResp) isMessage_Type()  {}

func (m *Message) GetType() isMessage_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Message) GetReqVote() *RequestVote {
	if x, ok := m.GetType().(*Message_ReqVote); ok {
		return x.ReqVote
	}
	return nil
}

func (m *Message) GetReqVoteResp() *RequestVoteResponse {
	if x, ok := m.GetType().(*Message_ReqVoteResp); ok {
		return x.ReqVoteResp
	}
	return nil
}

func (m *Message) GetAppend() *AppendEntries {
	if x, ok := m.GetType().(*Message_Append); ok {
		return x.Append
	}
	return nil
}

func (m *Message) GetAppendResp() *AppendEntriesResponse {
	if x, ok := m.GetType().(*Message_AppendResp); ok {
		return x.AppendResp
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Message) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Message_ReqVote)(nil),
		(*Message_ReqVoteResp)(nil),
		(*Message_Append)(nil),
		(*Message_AppendResp)(nil),
	}
}

func init() {
	proto.RegisterEnum("types.Entry_OpType", Entry_OpType_name, Entry_OpType_value)
	proto.RegisterType((*LogHeader)(nil), "types.LogHeader")
	proto.RegisterType((*RequestVote)(nil), "types.RequestVote")
	proto.RegisterType((*RequestVoteResponse)(nil), "types.RequestVoteResponse")
	proto.RegisterType((*Entry)(nil), "types.Entry")
	proto.RegisterType((*AppendEntries)(nil), "types.AppendEntries")
	proto.RegisterType((*AppendEntriesResponse)(nil), "types.AppendEntriesResponse")
	proto.RegisterType((*Message)(nil), "types.Message")
}

func init() { proto.RegisterFile("types/types.proto", fileDescriptor_2c0f90c600ad7e2e) }

var fileDescriptor_2c0f90c600ad7e2e = []byte{
	// 596 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x4d, 0x6b, 0xdb, 0x40,
	0x10, 0xd5, 0xda, 0xfa, 0xb0, 0x47, 0x69, 0x70, 0x37, 0x29, 0x88, 0x10, 0x14, 0xa1, 0x43, 0xea,
	0x4b, 0x95, 0xe0, 0xd2, 0x6b, 0x20, 0x6e, 0xd3, 0x3a, 0x90, 0xc4, 0x66, 0x09, 0x85, 0x1e, 0x15,
	0x6b, 0xa2, 0x1a, 0x6c, 0xad, 0x22, 0xc9, 0x69, 0xfd, 0x0b, 0x7a, 0xed, 0xad, 0x97, 0xfe, 0x95,
	0xde, 0x73, 0xcc, 0xb1, 0x50, 0x08, 0xc5, 0xfe, 0x05, 0xbd, 0xf6, 0x54, 0xb4, 0x92, 0x1c, 0x85,
	0x0a, 0xd3, 0x5e, 0xc4, 0xce, 0xce, 0xbc, 0xd9, 0xf7, 0xde, 0x0c, 0x82, 0xc7, 0xc9, 0x2c, 0xc4,
	0x78, 0x4f, 0x7c, 0x9d, 0x30, 0xe2, 0x09, 0xa7, 0x8a, 0x08, 0xb6, 0x9e, 0xf9, 0xa3, 0xe4, 0xfd,
	0xf4, 0xc2, 0x19, 0xf2, 0xc9, 0x9e, 0xcf, 0x7d, 0xbe, 0x27, 0xb2, 0x17, 0xd3, 0x4b, 0x11, 0x89,
	0x40, 0x9c, 0x32, 0x94, 0xfd, 0x02, 0x9a, 0x27, 0xdc, 0xef, 0xa1, 0xeb, 0x61, 0x44, 0x29, 0xc8,
	0x09, 0x46, 0x13, 0x83, 0x58, 0xa4, 0x2d, 0x33, 0x71, 0xa6, 0x9b, 0xa0, 0x8c, 0x02, 0x0f, 0x3f,
	0x1a, 0x35, 0x71, 0x99, 0x05, 0xf6, 0x17, 0x02, 0x3a, 0xc3, 0xab, 0x29, 0xc6, 0xc9, 0x5b, 0x9e,
	0x60, 0x25, 0xb2, 0x0d, 0xcd, 0xa1, 0x1b, 0x78, 0x23, 0xcf, 0x4d, 0x30, 0x43, 0x77, 0xe1, 0xf7,
	0xdd, 0x8e, 0x7a, 0xc6, 0x3d, 0x3c, 0x7e, 0xc5, 0xee, 0x93, 0xd4, 0x00, 0x2d, 0x8c, 0x30, 0x6d,
	0x64, 0xd4, 0x2d, 0xd2, 0x6e, 0xb0, 0x22, 0xa4, 0xfb, 0xa0, 0x8d, 0xdd, 0x38, 0x39, 0xe1, 0xbe,
	0x21, 0x5b, 0xa4, 0xad, 0x77, 0x5a, 0x4e, 0xa6, 0x79, 0x49, 0xba, 0x2b, 0xdf, 0xdc, 0xed, 0x48,
	0xac, 0x28, 0xb3, 0x3f, 0x11, 0xd8, 0x28, 0x31, 0x63, 0x18, 0x87, 0x3c, 0x88, 0xab, 0x19, 0x5a,
	0xa0, 0x5c, 0xf3, 0x04, 0xa3, 0x0a, 0x76, 0x59, 0x62, 0x05, 0x33, 0x0b, 0xf4, 0xb4, 0xe4, 0x4d,
	0xe4, 0x06, 0x09, 0x7a, 0x82, 0x5d, 0x83, 0x95, 0xaf, 0xec, 0xaf, 0x04, 0x94, 0xa3, 0x20, 0x89,
	0x66, 0xff, 0xee, 0x2b, 0x7d, 0x0a, 0x72, 0xaa, 0x4f, 0x3c, 0xb6, 0xde, 0xd9, 0xc8, 0xc5, 0x8a,
	0x2e, 0x4e, 0x3f, 0x3c, 0x9f, 0x85, 0xc8, 0x44, 0x01, 0x5d, 0x87, 0x1a, 0x0f, 0xc5, 0xab, 0x6b,
	0xac, 0xc6, 0x43, 0x7b, 0x1f, 0xd4, 0x2c, 0x4f, 0x9b, 0xa0, 0x1c, 0x9d, 0x0e, 0xce, 0xdf, 0xb5,
	0x24, 0xda, 0x00, 0xf9, 0xac, 0xdf, 0x1f, 0xb4, 0x08, 0xd5, 0xa0, 0x7e, 0x38, 0x18, 0xb4, 0x6a,
	0xe9, 0xd5, 0xcb, 0xfe, 0xd9, 0xeb, 0x56, 0xdd, 0xfe, 0x41, 0xe0, 0xd1, 0x61, 0x18, 0x62, 0xe0,
	0xa5, 0xed, 0x47, 0x18, 0x57, 0xd2, 0xb4, 0x41, 0x1d, 0x0b, 0x9f, 0x2b, 0x3c, 0xca, 0x33, 0xe9,
	0x90, 0xc2, 0x08, 0xaf, 0xd3, 0x21, 0xd5, 0x57, 0x0f, 0x29, 0x2f, 0xa3, 0x5b, 0xd0, 0x18, 0xf2,
	0xc9, 0x64, 0x54, 0x38, 0x27, 0xb3, 0x65, 0x4c, 0xb7, 0xa1, 0x19, 0xa1, 0xeb, 0x1d, 0x0b, 0x73,
	0x14, 0x91, 0xbc, 0xbf, 0xa0, 0xbb, 0xa0, 0x61, 0x46, 0xd7, 0x50, 0xad, 0x7a, 0x5b, 0xef, 0xac,
	0x95, 0x3d, 0x62, 0x45, 0xd2, 0xfe, 0x46, 0xe0, 0xc9, 0x03, 0x75, 0x2b, 0x17, 0x61, 0x17, 0x1a,
	0x97, 0x7c, 0x3c, 0xe6, 0x1f, 0x2a, 0x75, 0x2e, 0x73, 0xe9, 0x3a, 0xc4, 0xd3, 0xe1, 0x10, 0xe3,
	0xb8, 0x58, 0x87, 0x3c, 0xfc, 0xff, 0x45, 0x5d, 0xad, 0xd3, 0xfe, 0x45, 0x40, 0x3b, 0xc5, 0x38,
	0x76, 0x7d, 0xa4, 0x0e, 0x68, 0x11, 0x5e, 0x89, 0x25, 0x24, 0xa2, 0x37, 0xcd, 0x7b, 0x97, 0xf6,
	0xbc, 0x27, 0xb1, 0xa2, 0x88, 0x1e, 0x80, 0x9e, 0x1f, 0x53, 0xd1, 0x42, 0x90, 0xde, 0xd9, 0xfa,
	0x1b, 0x53, 0x58, 0xd2, 0x93, 0x58, 0x19, 0x40, 0x1d, 0x50, 0x5d, 0x61, 0x5d, 0x3e, 0xce, 0xcd,
	0x1c, 0xfa, 0xc0, 0xcf, 0x9e, 0xc4, 0xf2, 0x2a, 0x7a, 0x00, 0x90, 0x9d, 0xc4, 0x73, 0x99, 0xfc,
	0xed, 0x2a, 0x4c, 0xe9, 0xc1, 0x12, 0xa2, 0xab, 0x66, 0x4b, 0xdf, 0x35, 0x6e, 0xe6, 0x26, 0xb9,
	0x9d, 0x9b, 0xe4, 0xe7, 0xdc, 0x24, 0x9f, 0x17, 0xa6, 0x74, 0xbb, 0x30, 0xa5, 0xef, 0x0b, 0x53,
	0xba, 0x50, 0xc5, 0xcf, 0xea, 0xf9, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x46, 0x46, 0x0c, 0x18,
	0xf7, 0x04, 0x00, 0x00,
}

func (m *LogHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.LastLog.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.PreVote {
		i--
		if m.PreVote {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Candidate != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Candidate))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestVoteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestVoteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestVoteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VoteGranted {
		i--
		if m.VoteGranted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PreVote {
		i--
		if m.PreVote {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Voter != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Voter))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Op) > 0 {
		i -= len(m.Op)
		copy(dAtA[i:], m.Op)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Op)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppendEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendEntries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendEntries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ReadIndex != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ReadIndex))
		i--
		dAtA[i] = 0x28
	}
	if m.Commited != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Commited))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.PrevLog.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Leader != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppendEntriesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendEntriesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendEntriesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadIndex != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ReadIndex))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.LastLog.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Follower != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Follower))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Message_ReqVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_ReqVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReqVote != nil {
		{
			size, err := m.ReqVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Message_ReqVoteResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_ReqVoteResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReqVoteResp != nil {
		{
			size, err := m.ReqVoteResp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Message_Append) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_Append) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Append != nil {
		{
			size, err := m.Append.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Message_AppendResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_AppendResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppendResp != nil {
		{
			size, err := m.AppendResp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LogHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovTypes(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovTypes(uint64(m.Index))
	}
	return n
}

func (m *RequestVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovTypes(uint64(m.Term))
	}
	if m.Candidate != 0 {
		n += 1 + sovTypes(uint64(m.Candidate))
	}
	if m.PreVote {
		n += 2
	}
	l = m.LastLog.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *RequestVoteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovTypes(uint64(m.Term))
	}
	if m.Voter != 0 {
		n += 1 + sovTypes(uint64(m.Voter))
	}
	if m.PreVote {
		n += 2
	}
	if m.VoteGranted {
		n += 2
	}
	return n
}

func (m *Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovTypes(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovTypes(uint64(m.Index))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.Op)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AppendEntries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovTypes(uint64(m.Term))
	}
	if m.Leader != 0 {
		n += 1 + sovTypes(uint64(m.Leader))
	}
	l = m.PrevLog.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Commited != 0 {
		n += 1 + sovTypes(uint64(m.Commited))
	}
	if m.ReadIndex != 0 {
		n += 1 + sovTypes(uint64(m.ReadIndex))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AppendEntriesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovTypes(uint64(m.Term))
	}
	if m.Follower != 0 {
		n += 1 + sovTypes(uint64(m.Follower))
	}
	if m.Success {
		n += 2
	}
	l = m.LastLog.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.ReadIndex != 0 {
		n += 1 + sovTypes(uint64(m.ReadIndex))
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *Message_ReqVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReqVote != nil {
		l = m.ReqVote.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Message_ReqVoteResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReqVoteResp != nil {
		l = m.ReqVoteResp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Message_Append) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Append != nil {
		l = m.Append.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Message_AppendResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppendResp != nil {
		l = m.AppendResp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LogHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Candidate", wireType)
			}
			m.Candidate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Candidate |= NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreVote", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreVote = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastLog.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestVoteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestVoteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestVoteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			m.Voter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Voter |= NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreVote", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreVote = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteGranted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VoteGranted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Entry_OpType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = append(m.Op[:0], dAtA[iNdEx:postIndex]...)
			if m.Op == nil {
				m.Op = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrevLog.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commited", wireType)
			}
			m.Commited = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commited |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadIndex", wireType)
			}
			m.ReadIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendEntriesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendEntriesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendEntriesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follower", wireType)
			}
			m.Follower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Follower |= NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastLog.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadIndex", wireType)
			}
			m.ReadIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_ReqVote{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqVoteResp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RequestVoteResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_ReqVoteResp{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Append", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendEntries{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_Append{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppendResp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendEntriesResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_AppendResp{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
